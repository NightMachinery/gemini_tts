#+TITLE: gemini_tts/todo

* IF `--files-as-chunk-boundary` (true by default) when reading multiple input files, treat each file as a chunk (break into further chunks if big enough)
This leads to more semantic chunking.

* argparse: Interpolate the default in the help strings instead of hardcoding it.

* preprocess
#+BEGIN_SRC markdown
Add `--preprocess=1`.

If `--preprocess >= 1`:
preprocess text to remove subsequent blank lines (i.e., replace `\n\n\n` with `\n\n` until no more possible)
#+END_SRC

* DONE =_determine_speakers=: see what happens if we increase the number of automatically determined speakers to more than the actual speaker number.
If nothing breaks, it's a good idea to set higher limit. (allows guests in the podcasts, etc.)
** fixed it and now it works, BUT gemini only supports two speakers.

* DONE allow specifiying a file where each line is an API key.
When this file is specified, if `--parallel=auto`, then use as many parallel agents as there are keys (but each agent should use its own key).

When a key fails with quota failure, mark it in an in-memory structure as exhausted, and if the parallel agents were created with `auto`, decrease agents by one. Retry that chunk using other agents instead of failing. Only fail when all keys have failed.

Any ideas or improvements?

* DONE If the output path contains dirs, create them if they don't exist

* DONE If the output path ends with `/`, add the basename (sans extension) of the first input file to it.

* DONE initial project description
#+BEGIN_SRC markdown
I want you to develop a `gemini_tts.py input_path ... ` multi-speaker TTS (podcast script into audio) script that:
- first read and join all input paths using `\n\n`
- has a function to deterministically break the given input into chunks each lower than `--max-chunk-tokens=8192` on semantic boundaries (preferably on speaker boundaries)
- has `--speakers='Host A,Host B` support, by default set this to `"auto:2"` which will use regexes `^[^:]{1,25}:` to find all possible speaker labels and select the N  (here 2) most frequent ones as the speaker labels (strip ending `:`).
- before doing that, normalize speaker labels. some markdown docs might bold or italicize them, and we dont want that, so first replace all using regex
- also supports `--no-speakers` to disable multi speaker mode entirely (should also skip the normalization above)
- uses async api and can do the api calls for chunks in parallel: `--parallel=1`
- saves each chunk to `${out}_i.wav` and support `-o,--out`, by default just strip the extension of the first input path
- shows progress
- will also save each chunk as `tmp_${out}_i.md`
- will check if the saved chunk exists and is the same, and if its audio file already exists. if so, skips redoing that chunk.
- will redo chunks `--retries=3 --retry-sleep=70`.
- will finally merge all the wav files into a single mp3 file using ffmpeg and VBR quality 3. wont run if at least one chunk failed to process.
- create as a reusable library, and put the cli UI in another module which imports the library. I want to also expose this as a Telegram bot later.
- use dataclasses for passing multiple outputs between functions
- have a dataclass for the final output which has a `chunks: List[Chunk]` (Chunk: text, text path, audio path), `final_audio_path`, etc.
- add Optional removal of intermediate files with `--cleanup-chunks` which will remove the chunk audio and text files after merging them into the final audio file. wont run if at least one chunk failed to process.

Any questions or ideas to further improve?
#+END_SRC

#+BEGIN_SRC markdown
Here are some example codes to help you get up-to-speed with the gemini tts api.
#+END_SRC

